# The data {#data}

## Sample values {#samplevalues}
Most of the examples in the book are based on three imaginary samples (`x`, `y` and `y2`). Each is normally distributed and is made up of 50 observations:

* `x` has a mean of 0 and a standard deviation of 1
* `y` has a mean of 0.3 and a standard deviation of 2
* `y2`has a mean of 0.5 and a standard deviation of 1.5

`x` and `y` can be thought of as samples from different populations (e.g. 50 women and 50 men), while `y` and `y2` are samples of the same individuals at different points in time (the same 50 men before and after participating in a new drug trial).

We begin by creating a function that will allow us to produce samples of a given size (`N`) with a specified mean (`mu`) and standard deviation (`sd`):

```{r, message = FALSE}
library(tidyverse)
rnorm_fixed = function(N, mu = 0, sd = 1){scale(rnorm(N))*sd + mu}
```

Now we can create our three samples:

```{r}
# Set the seed so our 'random' results match those in the original book
set.seed(40)

# Create the samples:
x = rnorm_fixed(N = 50, mu=0, sd=1)
y = rnorm_fixed(N = 50, mu=0.3, sd=2)
y2 = rnorm_fixed(N = 50, mu=0.5, sd=1.5)
```

Lets also combine these samples into 'wide' and 'long' data frames. This doesn't change any of the values, it just rearranges to data into different layouts which can sometimes be easier to work with (e.g. when producing plots):
```{r, warning = FALSE}
# The wide layout is a dataframe with three columns, one for each of x, y and y2
mydata_wide <- tibble(x = x, y = y, y2 = y2)

# the long layout has two columns: one listing the group to which each observation 
# belongs (x, y or y2), and another column with the corresponding value
mydata_long <- mydata_wide %>% 
  gather(group,value,x:y2)
  
```

Here's what our three samples look like when plotted. Note the different mean (0.0, 0.3 and 0.5) and the different 'spread' of values for each group (reflecting their different standard deviations).

```{r, echo = FALSE, warning = FALSE, fig.cap = 'Our sample data',fig.align = 'center',fig.width= 5,fig.height=4}
ggplot(mydata_long, aes(x=group, y = value, color = group)) +
  geom_jitter(width = 0.1, alpha = .75, size =2) + 
  stat_summary(fun.y= mean, 
                  fun.ymin=mean, 
                  fun.ymax=mean, 
                  geom="crossbar", 
                  width=0.5, 
                  size=0.2,
                  color="black") +
  stat_summary(fun.y=mean, 
                  colour="black", 
                  geom="text",
                  show_guide = FALSE, 
                  vjust=-0.7, 
                  aes(label=round(..y..,2))) 
```

## 'Signed rank' values {#ranktrans}

Most common tests demonstrated in the book use the _actual_ values from the samples above. However, some tests also use their _rank-transformed_ values. Specifically, the _signed rank_ of the values is used. 

What is meant by signed ranks? The signed rank is found by:  
1. taking the _absolute_ value of each observation in the original sample; that is, expressing all the values as a positive number;  
2. finding the rank of each of these absolute values, where the smallest absolute value has a rank of 1; and  
3. giving each of these ranks the same sign (+ or -) as the original value.

For example, the numbers -2, 3, 7, -25, -30, 31 would have the signed ranks of -1, 2, 3, -4, -5, 6.

We create a function, `signed_rank()`, that we can use later to convert our actual values into signed ranks:

```{r}
# Takes any list of values, x, and calculates their signed rank
signed_rank = function(x) sign(x) * rank(abs(x))
```

Here is what our sample data would look like if we used signed ranks instead of actual values (I have remove the horizonal 'jitter' from this chart). Because each sample has 50 observations, each signed rank is somewhere between -50 and +50:

```{r, echo = FALSE, warning = FALSE, fig.cap = 'Our sample data, with signed ranks',fig.align = 'center',fig.width= 5,fig.height=4}
mydata_long_signed <- mydata_wide %>% 
  mutate_all(signed_rank) %>% 
  gather(group,signed_rank,x:y2)

ggplot(mydata_long_signed, aes(x=group, y = signed_rank, color = group)) +
  geom_jitter(width = 0, alpha = .75, size = 2) + 
  stat_summary(fun.y= mean, 
                  fun.ymin=mean, 
                  fun.ymax=mean, 
                  geom="crossbar", 
                  width=0.5, 
                  size=0.2,
                  color="black") +
  stat_summary(fun.y=mean, 
                  colour="black", 
                  geom="text",
                  show_guide = FALSE, 
                  vjust=-0.7, 
                  aes(label=round(..y..,1))) 
```

